# Year and Measurement Normalization Feature Patch
# Created: 2025-12-29
#
# This patch adds automatic conversion of spoken years and measurements to numeric format.
#
# Features:
# - Years: "twenty twenty-five" → "2025"
# - Measurements: "twenty five milligrams" → "25 mg"
#
# Files to modify:
# 1. src-tauri/src/audio_toolkit/text.rs
# 2. src-tauri/src/audio_toolkit/mod.rs
# 3. src-tauri/src/managers/transcription.rs

# ============================================================================
# FILE 1: src-tauri/src/audio_toolkit/text.rs
# ============================================================================
#
# INSTRUCTIONS:
# 1. Add `use regex::Regex;` to the imports at the top (line 3)
# 2. Add the normalize_years() function after line 8 (BKTREE_THRESHOLD constant)
# 3. Add helper functions: word_to_number(), parse_tens_and_ones(), parse_spoken_number()
# 4. Add normalize_measurements() function
# 5. Add tests at the end of the test module

# --- STEP 1: Add to imports (line 3) ---
use regex::Regex;

# --- STEP 2: Add after BKTREE_THRESHOLD constant (insert after line 8) ---

/// Normalizes spoken year phrases into numeric format
///
/// This function converts spoken year formats like "twenty twenty-five" or
/// "two thousand twenty-five" into numeric format like "2025".
///
/// Supported formats:
/// - "twenty twenty-five" → "2025"
/// - "two thousand twenty-five" → "2025"
/// - "nineteen ninety-nine" → "1999"
/// - "two thousand" → "2000"
///
/// # Arguments
/// * `text` - The input text to normalize
///
/// # Returns
/// The text with normalized year formats
pub fn normalize_years(text: &str) -> String {
    type ConverterFn = Box<dyn Fn(&regex::Captures) -> Option<String>>;

    let patterns: Vec<(Regex, ConverterFn)> = vec![
        // Pattern: "twenty twenty-five" or "twenty twenty five" → "2025"
        (
            Regex::new(r"(?i)\b(twenty)[\s-]+(twenty)[\s-]+(\w+)\b").unwrap(),
            Box::new(|caps: &regex::Captures| -> Option<String> {
                let last_digit = caps.get(3)?.as_str();
                let ones = word_to_number(last_digit)?;
                if ones <= 9 {
                    Some(format!("20{}", 20 + ones))
                } else {
                    None
                }
            }),
        ),
        // Pattern: "two thousand twenty-five" or "two thousand and twenty five" → "2025"
        // Process compound numbers first (two words)
        (
            Regex::new(r"(?i)\b(two\s+thousand)(?:\s+and)?\s+(\w+[\s-]+\w+)\b").unwrap(),
            Box::new(|caps: &regex::Captures| -> Option<String> {
                let year_part = caps.get(2)?.as_str().trim();
                let last_two = parse_tens_and_ones(year_part)?;
                if last_two <= 99 {
                    Some(format!("20{:02}", last_two))
                } else {
                    None
                }
            }),
        ),
        // Pattern: "two thousand twenty" or "two thousand and twenty" → "2020"
        // Process simple numbers second (one word)
        (
            Regex::new(r"(?i)\b(two\s+thousand)(?:\s+and)?\s+(\w+)\b").unwrap(),
            Box::new(|caps: &regex::Captures| -> Option<String> {
                let year_part = caps.get(2)?.as_str().trim();
                let last_two = word_to_number(year_part)?;
                if last_two <= 99 {
                    Some(format!("20{:02}", last_two))
                } else {
                    None
                }
            }),
        ),
        // Pattern: "nineteen ninety-nine" or "nineteen ninety nine" → "1999"
        (
            Regex::new(r"(?i)\b(nineteen)[\s-]+(\w+[\s-]+\w+|\w+)\b").unwrap(),
            Box::new(|caps: &regex::Captures| -> Option<String> {
                let second_part = caps.get(2)?.as_str();
                let last_two = if second_part.contains(' ') || second_part.contains('-') {
                    parse_tens_and_ones(second_part)?
                } else {
                    word_to_number(second_part)?
                };
                if last_two <= 99 {
                    Some(format!("19{:02}", last_two))
                } else {
                    None
                }
            }),
        ),
        // Pattern: "eighteen eighty-five" → "1885"
        (
            Regex::new(r"(?i)\b(eighteen)[\s-]+(\w+[\s-]+\w+|\w+)\b").unwrap(),
            Box::new(|caps: &regex::Captures| -> Option<String> {
                let second_part = caps.get(2)?.as_str();
                let last_two = if second_part.contains(' ') || second_part.contains('-') {
                    parse_tens_and_ones(second_part)?
                } else {
                    word_to_number(second_part)?
                };
                if last_two <= 99 {
                    Some(format!("18{:02}", last_two))
                } else {
                    None
                }
            }),
        ),
    ];

    let mut result = text.to_string();

    for (pattern, converter) in patterns {
        let mut replacements: Vec<(usize, usize, String)> = Vec::new();

        for caps in pattern.captures_iter(&result.clone()) {
            if let Some(replacement) = converter(&caps) {
                if let Some(full_match) = caps.get(0) {
                    replacements.push((full_match.start(), full_match.end(), replacement));
                }
            }
        }

        // Apply replacements in reverse order to maintain correct indices
        for (start, end, replacement) in replacements.into_iter().rev() {
            result.replace_range(start..end, &replacement);
        }
    }

    result
}

/// Converts a word to its numeric value (0-99)
fn word_to_number(word: &str) -> Option<u32> {
    let word_lower = word.to_lowercase();
    match word_lower.as_str() {
        "zero" | "oh" => Some(0),
        "one" => Some(1),
        "two" => Some(2),
        "three" => Some(3),
        "four" => Some(4),
        "five" => Some(5),
        "six" => Some(6),
        "seven" => Some(7),
        "eight" => Some(8),
        "nine" => Some(9),
        "ten" => Some(10),
        "eleven" => Some(11),
        "twelve" => Some(12),
        "thirteen" => Some(13),
        "fourteen" => Some(14),
        "fifteen" => Some(15),
        "sixteen" => Some(16),
        "seventeen" => Some(17),
        "eighteen" => Some(18),
        "nineteen" => Some(19),
        "twenty" => Some(20),
        "thirty" => Some(30),
        "forty" => Some(40),
        "fifty" => Some(50),
        "sixty" => Some(60),
        "seventy" => Some(70),
        "eighty" => Some(80),
        "ninety" => Some(90),
        _ => None,
    }
}

/// Parses phrases like "twenty-five" or "twenty five" into numeric value
fn parse_tens_and_ones(phrase: &str) -> Option<u32> {
    let parts: Vec<&str> = phrase.split([' ', '-']).collect();

    if parts.len() == 1 {
        return word_to_number(parts[0]);
    }

    if parts.len() == 2 {
        let tens = word_to_number(parts[0])?;
        let ones = word_to_number(parts[1])?;
        if (20..=90).contains(&tens) && ones <= 9 {
            return Some(tens + ones);
        }
    }

    None
}

/// Converts a spoken number phrase to numeric value
/// Handles numbers from 0 to 9999
fn parse_spoken_number(text: &str) -> Option<u32> {
    let text = text.trim().to_lowercase();

    // First try to parse using parse_tens_and_ones which handles hyphens
    if let Some(result) = parse_tens_and_ones(&text) {
        return Some(result);
    }

    let parts: Vec<&str> = text.split_whitespace().collect();

    // Handle simple single-word numbers
    if parts.len() == 1 {
        return word_to_number(parts[0]);
    }

    // Handle compound numbers like "twenty five"
    if parts.len() == 2 {
        // Check for "X hundred" pattern
        if parts[1] == "hundred" {
            let hundreds = word_to_number(parts[0])?;
            if hundreds <= 9 {
                return Some(hundreds * 100);
            }
        }
        // Already tried parse_tens_and_ones above
    }

    // Handle patterns like "one hundred twenty" or "two hundred fifty"
    if parts.len() >= 3 && parts[1] == "hundred" {
        let hundreds = word_to_number(parts[0])?;
        if hundreds > 9 {
            return None;
        }
        let base = hundreds * 100;

        // Join remaining parts and parse as tens/ones
        let remainder = parts[2..].join(" ");
        if let Some(last_two) = parse_tens_and_ones(&remainder) {
            return Some(base + last_two);
        } else {
            // Maybe it's just "X hundred" with no remainder
            return Some(base);
        }
    }

    None
}

/// Normalizes spoken measurements into numeric format with abbreviated units
///
/// This function converts spoken measurements like "twenty five milligrams" or
/// "one hundred fifty pounds" into numeric format like "25 mg" or "150 lbs".
///
/// Supported units:
/// - Weight: milligrams (mg), grams (g), kilograms (kg), pounds (lbs), ounces (oz)
/// - Length: millimeters (mm), centimeters (cm), meters (m), kilometers (km), inches (in), feet (ft), yards (yd), miles (mi)
/// - Volume: milliliters (ml), liters (l), gallons (gal), quarts (qt), pints (pt), cups (c), tablespoons (tbsp), teaspoons (tsp)
///
/// # Arguments
/// * `text` - The input text to normalize
///
/// # Returns
/// The text with normalized measurement formats
pub fn normalize_measurements(text: &str) -> String {
    // Define unit mappings: (full_name, abbreviation)
    let units = vec![
        // Weight
        ("milligrams?", "mg"),
        ("grams?", "g"),
        ("kilograms?", "kg"),
        ("pounds?", "lbs"),
        ("ounces?", "oz"),
        // Length
        ("millimeters?", "mm"),
        ("centimeters?", "cm"),
        ("meters?", "m"),
        ("kilometers?", "km"),
        ("inches?", "in"),
        ("feet", "ft"),
        ("foot", "ft"),
        ("yards?", "yd"),
        ("miles?", "mi"),
        // Volume
        ("milliliters?", "ml"),
        ("liters?", "l"),
        ("gallons?", "gal"),
        ("quarts?", "qt"),
        ("pints?", "pt"),
        ("cups?", "c"),
        ("tablespoons?", "tbsp"),
        ("teaspoons?", "tsp"),
    ];

    let mut result = text.to_string();

    for (unit_pattern, unit_abbr) in units {
        // Pattern matches 1-4 words before the unit
        // Try matching from longest to shortest to capture compound numbers first
        let patterns_to_try = vec![
            // Four words: "one hundred fifty five"
            format!(r"(?i)\b(\w+\s+\w+\s+\w+\s+\w+)\s+({})\b", unit_pattern),
            // Three words: "one hundred fifty"
            format!(r"(?i)\b(\w+\s+\w+\s+\w+)\s+({})\b", unit_pattern),
            // Two words: "twenty five"
            format!(r"(?i)\b(\w+\s+\w+)\s+({})\b", unit_pattern),
            // One word: "five"
            format!(r"(?i)\b(\w+)\s+({})\b", unit_pattern),
        ];

        for pattern_str in patterns_to_try {
            if let Ok(pattern) = Regex::new(&pattern_str) {
                let mut replacements: Vec<(usize, usize, String)> = Vec::new();

                for caps in pattern.captures_iter(&result.clone()) {
                    if let Some(number_text) = caps.get(1) {
                        if let Some(number) = parse_spoken_number(number_text.as_str()) {
                            if let Some(full_match) = caps.get(0) {
                                let replacement = format!("{} {}", number, unit_abbr);
                                replacements.push((
                                    full_match.start(),
                                    full_match.end(),
                                    replacement,
                                ));
                            }
                        }
                    }
                }

                // Apply replacements in reverse order to maintain correct indices
                for (start, end, replacement) in replacements.into_iter().rev() {
                    result.replace_range(start..end, &replacement);
                }
            }
        }
    }

    result
}

# --- STEP 3: Add tests (inside #[cfg(test)] mod tests, before the closing brace) ---

    #[test]
    fn test_normalize_years_twenty_twenty_format() {
        assert_eq!(
            normalize_years("The meeting is in twenty twenty-five"),
            "The meeting is in 2025"
        );
        assert_eq!(
            normalize_years("In twenty twenty five we will meet"),
            "In 2025 we will meet"
        );
        assert_eq!(normalize_years("Back in twenty twenty-one"), "Back in 2021");
    }

    #[test]
    fn test_normalize_years_two_thousand_format() {
        assert_eq!(
            normalize_years("The year two thousand twenty-five"),
            "The year 2025"
        );
        assert_eq!(
            normalize_years("In two thousand and twenty-five"),
            "In 2025"
        );
        assert_eq!(
            normalize_years("The year two thousand twenty five"),
            "The year 2025"
        );
        assert_eq!(normalize_years("two thousand twenty"), "2020");
    }

    #[test]
    fn test_normalize_years_nineteen_format() {
        assert_eq!(
            normalize_years("Back in nineteen ninety-nine"),
            "Back in 1999"
        );
        assert_eq!(normalize_years("In nineteen ninety nine"), "In 1999");
        assert_eq!(
            normalize_years("The year nineteen eighty-five"),
            "The year 1985"
        );
    }

    #[test]
    fn test_normalize_years_eighteen_format() {
        assert_eq!(normalize_years("In eighteen eighty-five"), "In 1885");
        assert_eq!(normalize_years("Back in eighteen seventy"), "Back in 1870");
    }

    #[test]
    fn test_normalize_years_mixed_text() {
        assert_eq!(
            normalize_years("From nineteen ninety-nine to twenty twenty-five"),
            "From 1999 to 2025"
        );
        assert_eq!(
            normalize_years("Between two thousand twenty and twenty twenty-five"),
            "Between 2020 and 2025"
        );
    }

    #[test]
    fn test_normalize_years_no_match() {
        let text = "Hello world with no years";
        assert_eq!(normalize_years(text), text);
    }

    #[test]
    fn test_normalize_years_case_insensitive() {
        assert_eq!(normalize_years("In TWENTY TWENTY-FIVE"), "In 2025");
        assert_eq!(normalize_years("In Two Thousand Twenty-Five"), "In 2025");
    }

    #[test]
    fn test_word_to_number() {
        assert_eq!(word_to_number("twenty"), Some(20));
        assert_eq!(word_to_number("five"), Some(5));
        assert_eq!(word_to_number("ninety"), Some(90));
        assert_eq!(word_to_number("invalid"), None);
    }

    #[test]
    fn test_parse_tens_and_ones() {
        assert_eq!(parse_tens_and_ones("twenty-five"), Some(25));
        assert_eq!(parse_tens_and_ones("twenty five"), Some(25));
        assert_eq!(parse_tens_and_ones("ninety-nine"), Some(99));
        assert_eq!(parse_tens_and_ones("forty-two"), Some(42));
        assert_eq!(parse_tens_and_ones("twenty"), Some(20));
        assert_eq!(parse_tens_and_ones("invalid-value"), None);
    }

    #[test]
    fn test_normalize_measurements_weight() {
        assert_eq!(
            normalize_measurements("Take twenty five milligrams daily"),
            "Take 25 mg daily"
        );
        assert_eq!(
            normalize_measurements("She weighs fifty kilograms"),
            "She weighs 50 kg"
        );
        assert_eq!(
            normalize_measurements("Add ten grams of sugar"),
            "Add 10 g of sugar"
        );
        assert_eq!(normalize_measurements("Lost fifteen pounds"), "Lost 15 lbs");
    }

    #[test]
    fn test_normalize_measurements_length() {
        assert_eq!(
            normalize_measurements("He is six feet tall"),
            "He is 6 ft tall"
        );
        assert_eq!(
            normalize_measurements("The room is ten meters wide"),
            "The room is 10 m wide"
        );
        assert_eq!(
            normalize_measurements("Cut fifty centimeters of rope"),
            "Cut 50 cm of rope"
        );
        assert_eq!(normalize_measurements("Drive twenty miles"), "Drive 20 mi");
    }

    #[test]
    fn test_normalize_measurements_volume() {
        assert_eq!(
            normalize_measurements("Pour five hundred milliliters"),
            "Pour 500 ml"
        );
        assert_eq!(
            normalize_measurements("Add two liters of water"),
            "Add 2 l of water"
        );
        assert_eq!(
            normalize_measurements("One tablespoon of oil"),
            "1 tbsp of oil"
        );
    }

    #[test]
    fn test_normalize_measurements_compound_numbers() {
        assert_eq!(
            normalize_measurements("Take ninety nine milligrams"),
            "Take 99 mg"
        );
        assert_eq!(
            normalize_measurements("One hundred fifty pounds"),
            "150 lbs"
        );
    }

    #[test]
    fn test_normalize_measurements_singular_plural() {
        assert_eq!(
            normalize_measurements("One kilogram of flour"),
            "1 kg of flour"
        );
        assert_eq!(
            normalize_measurements("Two kilograms of flour"),
            "2 kg of flour"
        );
    }

    #[test]
    fn test_normalize_measurements_mixed_text() {
        assert_eq!(
            normalize_measurements("Take twenty five milligrams and walk five miles"),
            "Take 25 mg and walk 5 mi"
        );
    }

    #[test]
    fn test_normalize_measurements_no_match() {
        let text = "Hello world with no measurements";
        assert_eq!(normalize_measurements(text), text);
    }

    #[test]
    fn test_parse_spoken_number() {
        assert_eq!(parse_spoken_number("five"), Some(5));
        assert_eq!(parse_spoken_number("twenty five"), Some(25));
        assert_eq!(parse_spoken_number("ninety nine"), Some(99));
        assert_eq!(parse_spoken_number("one hundred"), Some(100));
        assert_eq!(parse_spoken_number("five hundred"), Some(500));
        assert_eq!(parse_spoken_number("one hundred fifty"), Some(150));
    }


# ============================================================================
# FILE 2: src-tauri/src/audio_toolkit/mod.rs
# ============================================================================
#
# INSTRUCTIONS:
# Change line 10 from:
#   pub use text::apply_custom_words;
# To:
#   pub use text::{apply_custom_words, normalize_measurements, normalize_years};

# BEFORE:
pub use text::apply_custom_words;

# AFTER:
pub use text::{apply_custom_words, normalize_measurements, normalize_years};


# ============================================================================
# FILE 3: src-tauri/src/managers/transcription.rs
# ============================================================================
#
# INSTRUCTIONS:
# 1. Update the import on line 1
# 2. Update the transcription processing around line 400

# --- Change 1: Update import (line 1) ---
# BEFORE:
use crate::audio_toolkit::apply_custom_words;

# AFTER:
use crate::audio_toolkit::{apply_custom_words, normalize_measurements, normalize_years};


# --- Change 2: Update transcription processing (around line 400) ---
# Find this section (after inference completes):
#
#         // Lock is released here after inference completes
#     };
#
# REPLACE THIS:
#         // Apply word correction if custom words are configured
#         let corrected_result = if !settings.custom_words.is_empty() {
#             apply_custom_words(
#                 &result.text,
#                 &settings.custom_words,
#                 settings.word_correction_threshold,
#             )
#         } else {
#             result.text
#         };
#
# WITH THIS:
        // Apply normalizations in sequence
        let year_normalized = normalize_years(&result.text);
        let measurement_normalized = normalize_measurements(&year_normalized);

        // Then apply word correction if custom words are configured
        let corrected_result = if !settings.custom_words.is_empty() {
            apply_custom_words(
                &measurement_normalized,
                &settings.custom_words,
                settings.word_correction_threshold,
            )
        } else {
            measurement_normalized
        };


# ============================================================================
# VERIFICATION
# ============================================================================
#
# After applying all changes, run these commands to verify:
#
# 1. Check compilation:
#    cargo check
#
# 2. Run tests:
#    cargo test --lib audio_toolkit::text --quiet
#
# Expected output:
#    test result: ok. 22 passed; 0 failed
#
# 3. Format code:
#    cargo fmt
#
# ============================================================================
# END OF PATCH
# ============================================================================
